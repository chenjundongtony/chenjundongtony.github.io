{"meta":{"title":"Tony","subtitle":"Show me the code!","description":"前端相关内容","author":"Tony","url":"http://www.chenjundong.cn"},"pages":[{"title":"about","date":"2018-05-25T03:22:03.000Z","updated":"2018-10-27T06:18:38.000Z","comments":true,"path":"about/index.html","permalink":"http://www.chenjundong.cn/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-05-25T03:19:56.000Z","updated":"2018-10-27T06:18:38.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.chenjundong.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-25T03:21:50.000Z","updated":"2019-02-16T08:26:37.893Z","comments":true,"path":"tags/index.html","permalink":"http://www.chenjundong.cn/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2018-05-25T03:24:58.000Z","updated":"2018-10-27T06:18:38.000Z","comments":true,"path":"相册/index.html","permalink":"http://www.chenjundong.cn/相册/index.html","excerpt":"","text":""}],"posts":[{"title":"如何实现一个深拷贝","slug":"如何实现一个深拷贝","date":"2019-04-07T01:24:00.000Z","updated":"2019-04-07T02:44:49.101Z","comments":true,"path":"2019/04/07/如何实现一个深拷贝/","link":"","permalink":"http://www.chenjundong.cn/2019/04/07/如何实现一个深拷贝/","excerpt":"","text":"如何实现一个深拷贝简单实现深拷贝可以拆分成 2 步，浅拷贝 + 递归，浅拷贝时判断属性值是否是对象，如果是对象就进行递归操作，两个一结合就实现了深拷贝。1234567891011121314151617181920212223242526272829303132333435363738// 浅拷贝的实现function cloneShallow(source) &#123; var target = &#123;&#125;; for (var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key)) &#123; target[key] = source[key]; &#125; &#125; return target;&#125;var a = &#123; name: &quot;Tony&quot;, book: &#123; title: &quot;Let me think&quot;, price: &quot;50&quot; &#125;, a1: undefined, a2: null, a3: 123&#125;var b = cloneShallow(a);a.name = &quot;前端进阶&quot;;a.book.price = &quot;55&quot;;console.log(a);// &#123; name: &apos;前端进阶&apos;,// book: &#123; title: &apos;Let me think&apos;, price: &apos;55&apos; &#125;,// a1: undefined,// a2: null,// a3: 123 &#125;console.log(b);// &#123; name: &apos;Tony&apos;,// book: &#123; title: &apos;Let me think&apos;, price: &apos;55&apos; &#125;,// a1: undefined,// a2: null,// a3: 123 &#125; 以上代码是浅拷贝实现，只要稍微改动下，加上是否是对象的判断并在相应的位置使用递归就可以实现简单深拷贝。 12345678910111213141516function cloneDeep1(source) &#123; var target = &#123;&#125;; for(var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key)) &#123; if (typeof source[key] === &apos;object&apos;) &#123; target[key] = cloneDeep1(source[key]); // 注意这里 &#125; else &#123; target[key] = source[key]; &#125; &#125; &#125; return target;&#125;var b = cloneDeep1(a);console.log(b); 一个简单的深拷贝就完成了，但是这个实现还存在很多问题。 1.没有对传入参数进行校验，传入 null 时应该返回 null 而不是 {}2.对于对象的判断逻辑不严谨，因为 typeof null === ‘object’3.没有考虑数组的兼容 拷贝数组下面，我们来看一下对于对象的判断，判断方案如下： 123function isObject(obj) &#123; return Object.prototype.toString.call(obj) === &apos;[object Object]&apos;;&#125; 但是用在这里并不合适，因为我们要保留数组这种情况，所以这里使用 typeof 来处理。 1234typeof null //&quot;object&quot;typeof &#123;&#125; //&quot;object&quot;typeof [] //&quot;object&quot;typeof function foo()&#123;&#125; //&quot;function&quot; (特殊情况) 改动过后的 isObject 函数为 123function isObject(obj) &#123; return typeof obj === &apos;object&apos; &amp;&amp; obj != null;&#125; 所以兼容数组的写法如下: 12345678910111213141516171819function cloneDeep2(source) &#123; if (!isObject(source)) return source; // 非对象返回自身 var target = Array.isArray(source) ? [] : &#123;&#125;; for(var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key)) &#123; if (isObject(source[key])) &#123; target[key] = cloneDeep2(source[key]); // 注意这里 &#125; else &#123; target[key] = source[key]; &#125; &#125; &#125; return target;&#125;var b = cloneDeep2(a);console.log(b); 循环引用我们知道 JSON 无法深拷贝循环引用，遇到这种情况会抛出异常 123a.circleRef = a;JSON.parse(JSON.stringify(a));// TypeError: Converting circular structure to JSON 1.使用哈希表 解决方案很简单，其实就是循环检测，我们设置一个数组或者哈希表存储已拷贝过的对象，当检测到当前对象已存在于哈希表中时，取出该值并返回即可。 12345678910111213141516171819function cloneDeep3(source, hash = new WeakMap()) &#123; if (!isObject(source)) return source; if (hash.has(source)) return hash.get(source); // 新增代码，查哈希表 var target = Array.isArray(source) ? [] : &#123;&#125;; hash.set(source, target); // 新增代码，哈希表设值 for(var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key)) &#123; if (isObject(source[key])) &#123; target[key] = cloneDeep3(source[key], hash); // 新增代码，传入哈希表 &#125; else &#123; target[key] = source[key]; &#125; &#125; &#125; return target;&#125; 测试一下，看看效果如何？ 123456789101112a.circleRef = a;var b = cloneDeep3(a);console.log(b);// &#123;// name: &quot;muyiy&quot;,// a1: undefined,// a2: null,// a3: 123,// book: &#123;title: &quot;You Don&apos;t Know JS&quot;, price: &quot;45&quot;&#125;,// circleRef: &#123;name: &quot;muyiy&quot;, book: &#123;…&#125;, a1: undefined, a2: null, a3: 123, …&#125;// &#125; 2.使用数组 这里使用了ES6 中的 WeakMap 来处理，那在 ES5 下应该如何处理呢？ 也很简单，使用数组来处理就好啦，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344function cloneDeep3(source, uniqueList) &#123; if (!isObject(source)) return source; if (!uniqueList) uniqueList = []; // 新增代码，初始化数组 var target = Array.isArray(source) ? [] : &#123;&#125;; // ============= 新增代码 // 数据已经存在，返回保存的数据 var uniqueData = find(uniqueList, source); if (uniqueData) &#123; return uniqueData.target; &#125;; // 数据不存在，保存源数据，以及对应的引用 uniqueList.push(&#123; source: source, target: target &#125;); // ============= for(var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key)) &#123; if (isObject(source[key])) &#123; target[key] = cloneDeep3(source[key], uniqueList); // 新增代码，传入数组 &#125; else &#123; target[key] = source[key]; &#125; &#125; &#125; return target;&#125;// 新增方法，用于查找function find(arr, item) &#123; for(var i = 0; i &lt; arr.length; i++) &#123; if (arr[i].source === item) &#123; return arr[i]; &#125; &#125; return null;&#125;// 用上面测试用例已测试通过 现在已经很完美的解决了循环引用这种情况，那其实还是一种情况是引用丢失，我们看下面的例子: 123456789var obj1 = &#123;&#125;;var obj2 = &#123;a: obj1, b: obj1&#125;;obj2.a === obj2.b; // truevar obj3 = cloneDeep2(obj2);obj3.a === obj3.b; // false 引用丢失在某些情况下是有问题的，比如上面的对象 obj2，obj2 的键值 a 和 b 同时引用了同一个对象 obj1，使用 cloneDeep2 进行深拷贝后就丢失了引用关系变成了两个不同的对象，那如何处理呢。 其实你有没有发现，我们的 cloneDeep3 已经解决了这个问题，因为只要存储已拷贝过的对象就可以了。 123var obj3 = cloneDeep3(obj2);obj3.a === obj3.b; // true 详细链接如下： https://mp.weixin.qq.com/s/q0_muijFLYMBpuvQfSc36A","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://www.chenjundong.cn/tags/js/"},{"name":"面试题","slug":"面试题","permalink":"http://www.chenjundong.cn/tags/面试题/"},{"name":"深拷贝","slug":"深拷贝","permalink":"http://www.chenjundong.cn/tags/深拷贝/"}]},{"title":"前端如何优化网站性能","slug":"前端如何优化网站性能","date":"2019-02-27T08:07:46.000Z","updated":"2019-02-27T09:34:16.020Z","comments":true,"path":"2019/02/27/前端如何优化网站性能/","link":"","permalink":"http://www.chenjundong.cn/2019/02/27/前端如何优化网站性能/","excerpt":"","text":"闲谈从前端层面如何优化网站性能 减少HTTP请求 在浏览器与服务器进行通信时，主要是通过 HTTP 进行通信。浏览器与服务器需要经过三次握手，每次握手需要花费大量时间。而且不同浏览器对资源文件并发请求数量有限（不同浏览器允许并发数），一旦 HTTP 请求数量达到一定数量，资源请求就存在等待状态，这是很致命的，因此减少 HTTP 的请求数量可以很大程度上对网站性能进行优化。 CSS Sprites 国内俗称CSS精灵，这是将多张图片合并成一张图片达到减少HTTP请求的一种解决方案，可以通过CSS的background属性来访问图片内容。这种方案同时还可以减少图片总字节数。 合并 CSS 和 JS 文件 现在前端有很多工程化打包工具，如：grunt、gulp、webpack等。为了减少 HTTP 请求数量，可以通过这些工具再发布前将多个CSS或者多个JS合并成一个文件。 采用 lazyLoad 俗称懒加载，可以控制网页上的内容在一开始无需加载，不需要发请求，等到用户操作真正需要的时候立即加载出内容。这样就控制了网页资源一次性请求数量。 控制资源文件加载优先级 浏览器在加载HTML内容时，是将HTML内容从上至下依次解析，解析到link或者script标签就会加载href或者src对应链接内容，为了第一时间展示页面给用户，就需要将CSS提前加载，不要受 JS 加载影响。所以一般情况下，都是CSS在头部，JS在底部。 利用浏览器缓存 浏览器缓存是将网络资源存储在本地，等到下次请求该资源时，如果资源已经存在就不需要到服务器再次请求资源，直接在本地读取资源。 减少重排（Reflow） 基本原理：重排是DOM的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 DOM 树上的所有其它结点的visibility属性，这也是Reflow低效的原因。如果Reflow的过于频繁，CPU使用率就会急剧上升。 减少Reflow，如果需要在DOM操作时添加样式，尽量使用 增加class属性，而不是通过style操作样式。 减少 DOM 操作 查找元素的优化 改变DOM，包括添加，修改，删除DOM 改变DOM的样式类等 批量修改DOM 减少iframe标签的使用 样式放在header中，脚本放在关闭标签之前 使用iconfont代替图标 https://www.iconfont.cn 网页从输入网址到渲染完成经历了哪些过程？ 输入网址； 发送到DNS服务器，并获取域名对应的web服务器对应的ip地址； 与web服务器建立TCP连接； 浏览器向web服务器发送http请求； web服务器响应请求，并返回指定url的数据（或错误信息，或重定向的新的url地址）； 浏览器下载web服务器返回的数据及解析html源文件； 生成DOM树，解析css和js，渲染页面，直至显示完成；","categories":[],"tags":[{"name":"优化","slug":"优化","permalink":"http://www.chenjundong.cn/tags/优化/"},{"name":"性能","slug":"性能","permalink":"http://www.chenjundong.cn/tags/性能/"}]},{"title":"常见的vue.js面试题","slug":"常见的vue.js面试题","date":"2019-02-27T05:02:28.000Z","updated":"2019-02-27T08:05:51.601Z","comments":true,"path":"2019/02/27/常见的vue.js面试题/","link":"","permalink":"http://www.chenjundong.cn/2019/02/27/常见的vue.js面试题/","excerpt":"","text":"常见的vue.js面试题 谈谈对MVVM开发模式的理解 MVVM分为Model、View、ViewModel三者。 Model：代表数据模型，数据和业务逻辑都在Model层中定义； View：代表UI视图，负责数据的展示； ViewModel：负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作； Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。 这种模式实现了Model和View的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作dom。 vue有哪些指令？ v-html、v-show、v-if、v-for等等。 v-if 和 v-show 有什么区别？ 在 block 和 none 来回切换；而v-if会控制这个 DOM 节点的存在与否。当我们需要经常切换某个元素的显示/隐藏时，使用v-show会更加节省性能上的开销；当只需要一次显示或隐藏时，使用v-if更加合理。 简述Vue的响应式原理 当一个Vue实例创建时，vue会遍历data选项的属性，用 Object.defineProperty 将它们转为getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。 Vue.js组件间通信中，如何在组件内部实现一个双向数据绑定？ 假设有一个输入框组件，用户输入时，同步父组件页面中的数据。 具体思路：父组件通过props传值给子组件，子组件通过 $emit 来通知父组件修改相应的props值，具体实现如下： 12345678910111213141516171819202122232425262728293031323334import Vue from &apos;vue&apos;const component = &#123; props: [ &apos;value&apos; ], template: ` &lt;div&gt; &lt;input type=&quot;text&quot; @input=&quot;handleInput&quot; :value=&quot;value&quot;&gt; &lt;/div&gt;`, data () &#123; return&#123;&#125; &#125;, methods: &#123; handleInput (e) &#123; this.$emit(&apos;input&apos;, e.target.value) &#125; &#125;&#125;new Vue(&#123; components: &#123; CompOne: component &#125;, el: &apos;#root&apos;, template: `&lt;div&gt; &lt;comp-one :value1=&quot;value&quot; @input=&quot; value = arguments[0]&quot;&gt;&lt;/comp-one&gt; &lt;/div&gt;`, data () &#123; return&#123; value: &apos;123&apos; &#125; &#125;&#125;) 可以看到，当输入数据时，父子组件中的数据是同步改变的 我们在父组件中做了两件事，一是给子组件传入props，二是监听input事件并同步自己的value属性。那么这两步操作能否再精简一下呢？答案是可以的，你只需要修改父组件： 12345template: ` &lt;div&gt; &lt;!--&lt;comp-one :value1=&quot;value&quot; @input=&quot;value = arguments[0]&quot;&gt;&lt;/comp-one&gt;--&gt; &lt;comp-one v-model=&quot;value&quot;&gt;&lt;/comp-one&gt; &lt;/div&gt;` v-model 实际上会帮我们完成上面的两步操作。 delete和Vue.delete删除数组的区别 delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。 Vue.delete 直接删除了数组 改变了数组的键值。","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://www.chenjundong.cn/tags/面试/"},{"name":"vue","slug":"vue","permalink":"http://www.chenjundong.cn/tags/vue/"},{"name":"vue.js","slug":"vue-js","permalink":"http://www.chenjundong.cn/tags/vue-js/"}]},{"title":"hexo 博客迁移","slug":"hexo-博客迁移","date":"2019-02-15T08:37:36.000Z","updated":"2019-02-15T08:50:12.000Z","comments":true,"path":"2019/02/15/hexo-博客迁移/","link":"","permalink":"http://www.chenjundong.cn/2019/02/15/hexo-博客迁移/","excerpt":"","text":"更换新电脑后，hexo博客需要整体迁移迁移工作分为两部分： 新电脑环境准备 全局安装hexo脚手架 1npm install hexo-cli -g 博客文件夹准备 12cd bloghexo init 依赖安装 12cd hexo npm install 将以前的文件迁移到新初始化的博客文件夹中 需要迁移的文件包括：theme, scaffolds, source, 站点_config.yml, package.json 不需要迁移的文件：.git , node_modules, public 迁移后，进行依赖包安装 1npm install 部署包安装 1npm install hexo-deployer-git --save 完成之后 123hexo ghexo s # 查看本地运行hexo d # 进行部署","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.chenjundong.cn/tags/hexo/"}]},{"title":"mac 命令行ftp使用","slug":"mac-命令行ftp使用","date":"2019-02-15T07:16:13.000Z","updated":"2019-02-15T08:53:40.000Z","comments":true,"path":"2019/02/15/mac-命令行ftp使用/","link":"","permalink":"http://www.chenjundong.cn/2019/02/15/mac-命令行ftp使用/","excerpt":"","text":"三种连接方式 图形化界面连接 打开finder, 在顶部导航栏找到 “前往”点击在“连接服务器” 一栏在弹出的窗口输入 ftp 地址点击连接 ： 输入用户名、密码即可进行文件上传，下载 命令行方式连接 由于新版os系统移除了ftp工具需要自己手动安装这里介绍 brew 进行安装homebrew 安装方式请进入官网按顺序执行homebrew官网中文版介绍详细，此处不再赘述 使用brew安装ftp123brew install telnetbrew install inetutilsbrew link --overwrite inetutils 此时原生ftp生效12345# 打开终端 连接ftpftp server-ip name xxxx: 此处要求输入用户名password: 此处输入密码ftp&gt; # 已进入ftp 上传1ftp&gt; put [local-file][remote-file] 如果不成功12345678ftp&gt; putftp&gt; [local-file]ftp&gt; [remote-file]eg:ftp&gt; putftp&gt; /users/documents/desktop/1.txtftp&gt; /远程端路径/1.txt 下载1ftp&gt; get [remote-file][local-file] 删除1ftp&gt; delete [remote-file] 注意：ftp不支持文件夹上传及下载 图形化软件FileZilaForkLiftTransmit此处给出 Transmit 链接Transmit","categories":[],"tags":[{"name":"ftp","slug":"ftp","permalink":"http://www.chenjundong.cn/tags/ftp/"},{"name":"mac","slug":"mac","permalink":"http://www.chenjundong.cn/tags/mac/"}]},{"title":"常用字符串API","slug":"常用字符串API","date":"2019-01-24T07:49:49.000Z","updated":"2019-01-25T09:28:06.000Z","comments":true,"path":"2019/01/24/常用字符串API/","link":"","permalink":"http://www.chenjundong.cn/2019/01/24/常用字符串API/","excerpt":"","text":"字符串常用API涉及 charAt() concat() indexOf() lastIndexOf() match() replace() slice() split()substr() toString() charAt() 获取指定位置字符charAt()12var str = 'this is code'str.charAt(5) // 'i' 返回指定下标位置的字符 concat() 拼接12var str = 'this is code'str.concat('code is here') // 'this is code code is here' 返回 拼接后的字符串 idnexOf() 获取指定字符串位置的下标123var str = 'this is code'str.indexOf('this') // 0 如果没有返回 -1str.indexOf('word') // -1 lastIndexOf() 获取指定字符串所在的最后一个下标12var str = 'this is code this is code'str.lastIndexOf('code') // 21 返回最后一个字符串的下标 如果没有 返回 -1 match() 获取指定字符串， 返回数组形式的字符串的相关信息12var str = 'this is code'str.match('code') // ['word', index:7, input:'hello world' , groups: undefined] replace() 查找并替换12var str = 'this is code'str.replace(/code/, 'word') // this is word slice() 截取字符串12var str = 'this is code'str.slice(3,4) // 's' slice(starti, endi) 含头不含尾 split() 切割12var str = 'this is code'str.split(\" \") // [ 'this' , 'is' , 'code'] 将字符串按 ' ' 进行分割, 并返回数组 substr() 截取, 获取指定下标的指定数目的字符12var str = ' this is code'str.substr(3, 6) // 'is is' substr(start , end) toString() 将数组转换为字符串12var arr = [1,2,3,4,5]arr.toString() // '1,2,3,4,5'","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://www.chenjundong.cn/tags/js/"}]},{"title":"web部分面试题(一)","slug":"web部分面试题","date":"2019-01-21T02:00:12.000Z","updated":"2019-01-21T09:45:22.000Z","comments":true,"path":"2019/01/21/web部分面试题/","link":"","permalink":"http://www.chenjundong.cn/2019/01/21/web部分面试题/","excerpt":"盒子模型盒子模型包括四部分：内容(content)、填充(padding)、边框(border)、边界(margin)盒子模型可以分为两种：IE盒子模型和W3C标准盒子模型IE 盒子模型：width = border + padding + content元素实际占地 ：margin + width w3c 盒子模型：width = content元素实际占地：margin + border + padding + content position包含几种属性？absolute和relative的区别static：默认状态、没有定位、正常流inherit：从父元素继承 position 属性的值fixed：生成绝对定位的元素（相对于当前视图窗口进行定位）absolute：生成绝对定位的元素（相对于外层第一个已定位的父元素定位）relative：生成相对定位的元素（相对于元素自身位置定位）","text":"盒子模型盒子模型包括四部分：内容(content)、填充(padding)、边框(border)、边界(margin)盒子模型可以分为两种：IE盒子模型和W3C标准盒子模型IE 盒子模型：width = border + padding + content元素实际占地 ：margin + width w3c 盒子模型：width = content元素实际占地：margin + border + padding + content position包含几种属性？absolute和relative的区别static：默认状态、没有定位、正常流inherit：从父元素继承 position 属性的值fixed：生成绝对定位的元素（相对于当前视图窗口进行定位）absolute：生成绝对定位的元素（相对于外层第一个已定位的父元素定位）relative：生成相对定位的元素（相对于元素自身位置定位） 前端性能优化减少http请求① CSS Sprites 合并图片② 合并脚本和样式表，尽量减少js和css的请求数量③ 实现文件分离 使用cdn 内容分布式网络CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术 缓存的使用（多个域名来提供缓存）GZIP 压缩你的 JS 和 CSS 文件 js线程与进程的区别？一个程序至少有一个进程,一个进程至少有一个线程; 线程的划分尺度小于进程,使得多线程程序的并发性高;进程在执行过程中拥有独立的内存单元,而多个线程共享内存,从而极大地提高了程序的运行效率; 线程在执行过程中与进程的区别：每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制;从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 JSONP是什么？它是如何实现跨域的？为域的几种方式是？JSONP(JSON with Padding)是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问; 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求（因为同源策略不阻止动态脚本插入，并且将脚本看作是从提供 Web 页面的域上加载的），然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。①. jsonp1234567891011121314151617function createJs(sUrl)&#123; var oScript = document.createElement('script'); oScript.type = 'text/javascript'; oScript.src = sUrl; document.getElementsByTagName('head')[0].appendChild(oScript); &#125; createJs('jsonp.js'); box(&#123; 'name': 'test' &#125;); function box(json)&#123; alert(json.name); &#125; ② CORSEXPRESS + CORS 简单跨域 ③ window.domain通过设置window.domain来处理跨域，但是只适用于不同子域的框架间的交互。所以使用的时候可以用一个隐藏的iframe来做一个代理，让这个iframe载入一个与你想要通过ajax获取数据的目标页面处在相同的域的页面。但 iframe 方式不建议使用。 ④ window.name是可以跨域的。window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。所以可以转化成字符串的数据都可以使用window.name来传递，比如json数据。 ⑤ ajaxjquery 封装的 $.ajax() 方法$.ajax()方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用1dataType: 'jsonp'; 使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 闭包内层函数能拿到外层函数的局部变量, 对局部变量进行操作,可反复使用;同时保护外层函数的局部变量不被污染;外层函数可以拿到内层函数的返回值;一个简单的闭包：12345678function outer()&#123; var a = 10; return function inner()&#123; return a+10; &#125;&#125;var num = outer();console.log(num()); 谈谈你对this的理解① this 的 指向问题② this 做了哪几件事 JS继承与原型问题Js的函数在创建时, 都有一个prototype属性,指向constructor(构造函数)属性, 指向proto属性,即原型对象, 也简称原型。每一个对象都有原型，在浏览器中它体现在一个隐藏的proto属性上; 当一个对象需要调用某个属性或方法时, 它会先在只身函数内部去找,如果没有找到, 会去最近的原型上查找该方法,如果没有找到,它会再次向上继续查找;这样逐级查找,一直找到了要找的方法。 这样链式查找的过程成为原型链。原型最后指向的是顶层的Object, 最终指向null。继承指的就是子对象继承父对象的属性和方法的这种过程。 一个页面从输入 URL 到 页面加载完成都发生了什么? DNS解析 DNS解析的过程就是寻找哪台机器上有你需要资源的过程,互联网上每一台计算机的唯一标识是它的IP地址, 网址就是从 URL 到 IP 地址的转换, 此过程成为DNS 解析 TCP连接 HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响 , HTTP 是 TCP 总集中的一种 , 前端使用 发送 HTTP 请求的方式来处理前后端的协调工作 发送HTTP请求 HTTP 请求主要发生在 客户端 发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)HTTP请求报文是由三部分组成: 请求行,请求头和请求主体 服务器处理请求并返回HTTP报文 对应的就是后端中的HTTP,后端从在固定的端口接收请求,响应包括三部分组成: 状态码, 响应报头和响应主体 EG： 状态码常见状态码 浏览器解析渲染页面 浏览器解析html 文件, 构建DOM 树, 解析CSS 文件构建渲染树, 渲染过程中, 进行 回流( reflow ) 和 重绘 (repain), 页面首次加载必经历回流 与 重绘 浏览器中的js 解释引擎 将请求到的数据 进行加载, html 渲染会等待js 加载并解析完毕后, 继续进行 渲染,原因是 JS 有可能修改DOM结构, JS执行完成前, 后续所有资源的下载是没有必要的, 这就是JS阻塞后续资源下载的根本原因; CSS文件的加载不影响JS文件的加载, 但是却影响JS文件的执行; JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。 连接结束","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://www.chenjundong.cn/tags/面试题/"}]},{"title":"数组api汇总","slug":"数组api汇总","date":"2019-01-16T03:27:58.000Z","updated":"2019-01-21T07:02:08.000Z","comments":true,"path":"2019/01/16/数组api汇总/","link":"","permalink":"http://www.chenjundong.cn/2019/01/16/数组api汇总/","excerpt":"Js数组api:涉及：String(),toString(),join(),concat(),slice(),splice(),pop(),push(),shift(),unshift() 将数组转化为字符串：2种Ⅰ.① String()将数组转化为字符串 分隔为 每个元素123var arr = [1,2,3]var a = String(arr) // 不修改原数组, 返回字符串console.log(a) // \"1,2,3\" String() 将 数组 强制 转换为字符串, 不修改原数组, 返回字符串② toString()123var arr = [1,2,3,4,5]arr.toString() // 不修改原数组, 返回字符串console.log(arr) // \"1,2,3,4,5\" Ⅱ. join123var arr = [1,2,3]var str = arr.join(\" - \") // join('自定义分隔符') 不修改原数组console.log(str) // \"1-2-3\"","text":"Js数组api:涉及：String(),toString(),join(),concat(),slice(),splice(),pop(),push(),shift(),unshift() 将数组转化为字符串：2种Ⅰ.① String()将数组转化为字符串 分隔为 每个元素123var arr = [1,2,3]var a = String(arr) // 不修改原数组, 返回字符串console.log(a) // \"1,2,3\" String() 将 数组 强制 转换为字符串, 不修改原数组, 返回字符串② toString()123var arr = [1,2,3,4,5]arr.toString() // 不修改原数组, 返回字符串console.log(arr) // \"1,2,3,4,5\" Ⅱ. join123var arr = [1,2,3]var str = arr.join(\" - \") // join('自定义分隔符') 不修改原数组console.log(str) // \"1-2-3\" join 将数组转换为字符串, 并将数组元素按自定义分隔符进行拼接如果省略分隔符, 直接转为数组 Ⅲ. concat()123var arr = [1,2,3]var newArr = arr.concat(10,20,30) // 不修改原数组, 返回一个新数组 console.log(newArr) // [1,2,3,10,20,30] concat() 如果concat()参数中包含数组, 则把数组元素打散, 返回新数组中 Ⅳ. slice()切割, slice() 不修改原数组返回新数组, 两个参数时, 返回的新数组规则：slice(starti,endi+1); 含头不含尾123var arr = [1,2,3,4,5,6]var newArr = arr.slice(2,3) // [3]var newArr2 = arr.slice(2,5) // [3,4,5] slice()一个参数: 返回参数值后面所有;123var arr = [1,2,3,4,5]var newArr = arr.slice(2)console.log(newArr) // [3,4,5] Ⅳ. splice()删除, 插入, 增加 注意： splice(index,how many, item1,item2…)直接修改原数组 ,返回执行后的新数组①. 一个参数123var arr = [1,2,3,4,5]arr.splice(2) // [3,4,5] 一个参数：规定删除的位置 返回执行后的新数组console.log(arr) // [1,2] 原数组被修改 ②. 两个参数123var arr = [1,2,3,4,5,6]arr.splice(1,2) // [2,3] 两个参数：(从参数的位置, 删除 参数个 元素) 返回删除的元素console.log(arr) // [1,4,5,6] 原数组被修改 ③. 三个及以上参数1234var arr = [1,2,3,4,5,6]arr.splice(1,2,10,20,30) // [2,3] 三个参数:(从参数的位置, 删除2个, 添加的元素)// 返回删除的元素console.log(arr) // [1,10,20,30,4,5,6] Ⅴ. pop() push()pop() 删除数组的最后一个, 并返回删除的元素123var arr = [10,20,30,40]arr.pop() // 40console.log(arr) // [10,20,30] push() 在数组的尾部添加 一个, 或多个元素, 返回执行后的数组长度123var arr = [10,20,30,40]arr.push(50) // 5console.log(arr) // [10,20,30,40,50] Ⅵ. shift() unshift()shift() 弹出数组的第一个元素, 并返回弹出的元素123var arr = [10,20,30,40]arr.shift() // 10console.log(arr) // [20,30,40] unshift() 在数组的头部插入元素, 并返回数组的长度123var arr = [10,20,30,40]arr.unshift(50) // 5 console.log(arr) // [50,10,20,30,40] Ⅶ. reverse()将数组元素进行反转 修改原数组123var arr = [10,20,30]arr.reverse() // [30,20,10] 返回修改后的数组console.log(arr) // [30,20,10] Ⅷ. toLocaleString()将数组转换为字符串, 不修改原数组123var arr = [10,20,30]arr.toLocaleString() // \"10,20,30\"console.log(arr) // [10,20,30]","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://www.chenjundong.cn/tags/js/"}]},{"title":"js作用域","slug":"js作用域","date":"2019-01-15T06:56:40.000Z","updated":"2019-01-15T09:32:16.000Z","comments":true,"path":"2019/01/15/js作用域/","link":"","permalink":"http://www.chenjundong.cn/2019/01/15/js作用域/","excerpt":"","text":"js作用域 js 作用域：分为全局与局部两种。 在script 分为全局变量、全局函数(局部变量存在于此) js解释引擎执行代码：自上而下 作用域链由内层向外层查找① 当我们使用一个变量时, 如果当前作用域中含有这个变量的声明语句, 就不会查找外面的其他作用域 12console.log(num);var num = 20; ② 当我们在某个作用域中使用变量时：使用情况有两种 直接使用： console.log(num); 当前作用域中没有这个变量的声明, 会向父级作用域查找; 如果找到了这个变量;使用父级作用域中这个变量的值; 如果没有找到,继续向上查找。。最终找到全局作用域,如果还没有,报错; ② 进行赋值 num = 100; 当前作用域中没有这个变量的声明,会向父级作用域查找; 如果找到了这个变量,修改父级作用域中这个变量的值; 如果没有找到,继续向上查找。。最终找到全局作用域,如果还没有,会创建一个全局变量; 题I.12345678910fun(); // 9 9 9console.log(c); // 9console.log(b); // 9console.log(a); // 报错 a is not definedfunction fun () &#123; var a = b = c = 9; // var a; a为局部, b, c 未声明直接赋值为全局 console.log(a); console.log(b); console.log(c);&#125; Ⅱ.123456789var num;function fun () &#123; var num; console.log(num); // undefined 声明未赋值 num = 20;&#125;num = 10;fun(); Ⅲ.12345678910111213var num = 10;fun();function fun () &#123; console.log(num); // 声明提前 undefined var num = 20; // 声明提前 值留在原地&#125;function aaa()&#123; var a = b = 10; &#125;aaa();console.log(a); // var a 为局部 报错 a is not definedconsole.log(b); Ⅳ.123456789function fun(a)&#123; // 形参 按值传递 var a; // 形参 会在局部作用域自动生成 a ,var a 失效 console.log(a); // 10 a = 20; console.log(a); // 20&#125;var a = 10;fun(a);console.log(a); // 10 Ⅴ.12345678910function box(obj)&#123; // 按址传递 console.log(obj); // &#123; &#125; obj.name='Lee'; // lee var obj = new Object(); obj.name='kkk'; // kkk console.log(obj);&#125;var obj = new Object();box(obj);console.log(obj.name); // lee Ⅵ.123456789101112131415161718function box(obj) &#123; var obj; console.log(obj); // test 按址传递 obj.name obj.name = 'Lee'; console.log(obj); // lee obj.name 的值进行更改 obj = new Object(); console.log(obj); // 新建空对象 &#123; &#125; obj.name = 'kkk'; console.log(obj); // kkk&#125;var obj = new Object();obj.name = 'test';box(obj);console.log(obj.name); // lee","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://www.chenjundong.cn/tags/js/"}]},{"title":"js 深浅拷贝  堆栈  基本数据类型 引用类型","slug":"js-深浅拷贝-堆栈-基本数据类型-引用类型","date":"2019-01-08T07:12:32.000Z","updated":"2019-01-14T06:54:24.000Z","comments":true,"path":"2019/01/08/js-深浅拷贝-堆栈-基本数据类型-引用类型/","link":"","permalink":"http://www.chenjundong.cn/2019/01/08/js-深浅拷贝-堆栈-基本数据类型-引用类型/","excerpt":"","text":"本文主要讲解一下js数据类型, 堆和栈, 以及什么是浅拷贝, 深拷贝 深拷贝与浅拷贝的主要区别： 在内存中的存储类型不同 堆和栈 与 js 数据类型栈(stack)为自动分配的内存空间,由系统释放;堆(heap) 动态分配的内存, 大小不定, 不会自动释放; js 数据类型分为：基本数据类型 &amp; 引用数据类型 基本数据类型 主要存放在栈内存中, 栈内存中的数据, 按值存放, 可以直接访问, 因此也可以称为 值类型, 数据在内存中创建后,开辟独立的内存空间, 基本数据类型的值不可变&lt; 1234var a = 'eric'var b = ab = 'hammer'console.log(a , b) // eric , hammer 基本数据类型比较的是值, 只要值相等就认为其相等 123var a = 1var b= trueconsole.log(a == b) // true 引用数据类型 存放在堆内存中 123var obj1 = &#123; name :'josh' &#125;var obj2 = &#123; name : 'hammer' &#125;var obj3 = &#123; name : 'eric' &#125; 如上代码：栈区存放 obj1 , obj2 , obj3 指向 堆内存中的 地址 引用类型值可变123var a = [1, 2, 3]a[1] = 5console.log(a[1]) // 5 ① 引用类型比较的是引用, 两个对象, 在栈中存放不同地址, 指向堆内存： 123var a = [1, 2, 3]var b = [1, 2, 3]console.log(a == b) // false ② 一个对象, 地址赋值给另外一个对象, 指向同一个地址:123var a = [1, 2 ,3]var b = aconsole.log( a == b) // true 赋值 与 浅拷贝12345678910111213141516171819202122232425262728293031323334var obj1 = &#123; 'name' : 'eric', 'age' : '18', 'tel' : [1,2,3] &#125;; var obj2 = obj1; function shallowCopy(obj) &#123; var clone1 = &#123; &#125;; // 在栈内存创建一个新对象, 指向堆内存的地址 for (var i in obj) &#123; if (obj.hasOwnProperty(i)) &#123; clone1[i] = obj[i]; &#125; &#125; return clone1; &#125; var obj3 = shallowCopy(obj1); // 创建了一个新对象, 并通过 浅clone 复制 其地址 obj2.name = \"hammer\"; obj3.age = \"20\"; // 新对象栈内存的值发生改变 obj2.tel[1] = [10]; obj3.tel[2] = [20]; console.log(obj1); // name:hammer age: 18 tel: 1, 10, 20 console.log(obj2); // name: hammer age: 18 tel: 1, 10, 20 console.log(obj3); // name: eric age: 20, tel : 1, 10, 20 浅拷贝只复制一层对象的属性，并不包括对象里面的为引用类型的数据。所以就会出现改变浅拷贝得到的 obj3 中的引用类型时，会使原始数据得到改变; 浅拷贝类似于 赋值。 深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象。 深拷贝： 递归调用具体请参考 其他js库 的写法","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://www.chenjundong.cn/tags/js/"}]},{"title":"常见的 http 状态响应码：200、301、302、304、400、405、500","slug":"http-状态响应码：200、301、302、304、400、405、500","date":"2019-01-08T07:06:04.000Z","updated":"2019-01-21T07:04:18.000Z","comments":true,"path":"2019/01/08/http-状态响应码：200、301、302、304、400、405、500/","link":"","permalink":"http://www.chenjundong.cn/2019/01/08/http-状态响应码：200、301、302、304、400、405、500/","excerpt":"","text":"前端常见的 http 请求状态码：200、304、404、500. 1xx 临时响应表示 临时响应, 需要请求者继续操作 2xx成功200 服务器已经成功处理了请求 xxx 重定向301 (永久移动) 请求的网页已永久移动到新的位置, (get 或 head 请求时), 会自动将请求转到新位置302 (临时移动) 服务器目前从不同位置的网页响应, 但请求应继续使用原有位置进行以后的请求304 (未修改) 距离上次请求后, 请求的网页未修改, 服务器返回此响应 4xx 请求错误400 (错误请求) 服务器不理解请求的语法401 (未授权) 请求要求身份验证403 (禁止) 服务器拒绝请求404 (未找到) 服务器找不到需要请求的资源405 (方法禁用) 禁用请求中指定的方法 5xx 服务器错误500 (服务器内部错误) 服务器遇到错误, 无法完成请求501 (尚未实施) 服务器不具备完成请求的功能, 如：无法识别请求方法504 (网关超时) 服务器作为网关或代理, 未及时从上游服务器收到请求505 (http 版本不支持) 服务器不支持请求中所用的 http协议版本","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://www.chenjundong.cn/tags/js/"}]},{"title":"js 隐式转换&强制转换","slug":"js-数据类型","date":"2019-01-07T06:26:17.000Z","updated":"2019-01-07T08:45:06.000Z","comments":true,"path":"2019/01/07/js-数据类型/","link":"","permalink":"http://www.chenjundong.cn/2019/01/07/js-数据类型/","excerpt":"","text":"js 数据类型分类js数据类型分为原始类型 和 引用类型，原始类型也被称为值类型 值类型字符串(String)、数字(Number)、布尔(Boolean)、空(Null)、未定义(Undefined) 引用数据类型对象(Object)、数组(Array)、函数(Function) 强制转换① Number() // 强制转换为nubmer② String() // 强制转换为string③ Boolean() // 强制转换为boolean 隐式转换JavaScript的数据类型分为六种：分别为null,undefined,boolean,string,number,objectobject是引用类型，其它的五种是基本类型或者是原始类型我们可以用typeof方法打印来某个是属于哪个类型 EG:123console.log(typeof('123')) // 输出stringconsole.log(typeof(123)) // 输出numberconsole.log(typeof(false)) // 输出boolean 运算规则① + 号 字符串与数字拼接 转为string② + 号 字符串与非数字拼接 转为string③ - 号 字符串与数字拼接 转为number④ - 号 字符串与非数字拼接 转为 number ⑤ - 与非纯数字拼接 返回 NaN == 运算1234567console.log( null == undefined ) // trueconsole.log( null == 0 ) // falseconsole.log( false == 0 ) // trueconsole.log( null == false ) // falseconsole.log( undefined == false ) // falseconsole.log( NaN == NaN ) // falseconsole.log( undefined == 0 ) // false","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://www.chenjundong.cn/tags/js/"}]},{"title":"mysql建库建表","slug":"mysql建库建表","date":"2019-01-03T08:59:08.000Z","updated":"2019-01-03T08:59:08.000Z","comments":true,"path":"2019/01/03/mysql建库建表/","link":"","permalink":"http://www.chenjundong.cn/2019/01/03/mysql建库建表/","excerpt":"","text":"数据库（Database）是按照数据结构来组织、存储和管理数据的仓库，每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。 mysql 数据库具有以下特点： 数据以表格的形式出现 每行为各种记录名称 每列为记录名称所对应的数据域 许多的行和列组成一张表单 若干的表单组成database 创建完整数据库12345678# 设置字符编码SET NAMES UTF8;# 如果数据库已经存在 丢弃DROP DATABASE IF EXISTS 库名;# 创建数据库 规定字符集CREATE DATABASE 数据库名 CHARSET = UTF8;# 使用此数据库USE 库名; 创建一张表格123456CREATE TABLE table_name( id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY, title VARCHAR(100) NOT NULL, author VARCHAR(40) NOT NULL, date DATE) mysql 增删改查 新增一条数据INSERT INTO table_name ( 列1, 列2 ) VALUES ( value1, value2 ); 更新一条数据UPDATE table_name SET 列名 = &#39;values&#39;,列名 = &#39;values&#39; WHERE 列名 = VALUES; 删除数据库，删除表，删除一条数据 123DROP DATABASE 库名;DROP TABLE 表名;DELETE FROM 表名 WHERE 限制条件; 修改表结构① 新增一列ALTER TABLE 表名 ADD 列名 列类型;② 修改表名ALTER TABLE 表名 rename 表名;③ 修改列名ALTER TABLE 表名 modify 列名 列类型; 查询 12SELECT * FROM 表名;SELECT 列名,列名 FROM 表名; ① 指定条件查询SELECT * FROM 表名 WHERE 列名 = &#39;&#39;; ② 按序列查询SELECT * FROM 表名 ORDER BY uid DESC; #DESC 倒序, ASC 顺序; ③ 按区间查询SELECT * FROM 表名 WHERE uid BETWEEN 2 AND 4; ④ like 模糊查询SELECT * FROM 表名 WHERE uname LIKE &quot;%ha%&quot;; ⑤ or 多条件查询SELECT * FROM 表名 WHERE uid = 2 or uid = 4; ⑥ group by 分组查询SELECT max(salary),gender FROM 表名 GROUP BY gender; 聚合函数max(),min(),sum(),avg() 完美解决乱码问题 首行set names utf8 create database 库名 charset = utf8; cmd 命令行 source 拖拽 mysql 文件 set charset gbk 查询 mysql 环境变量设置 windows + e , 打开文件夹资源管理器 空白处右键属性 , 找到高级系统设置 配置环境变量 找到 系统 path 属性 新建环境变量 粘贴 xampp 安装环境下 mysql/bin 的路径 如图：","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.chenjundong.cn/tags/mysql/"}]},{"title":"express cors 跨域","slug":"express-cors-跨域","date":"2018-12-26T02:20:43.000Z","updated":"2019-01-03T08:34:54.000Z","comments":true,"path":"2018/12/26/express-cors-跨域/","link":"","permalink":"http://www.chenjundong.cn/2018/12/26/express-cors-跨域/","excerpt":"","text":"expressExpress 是一个保持最小规模的灵活的 Node.js Web 应用程序开发框架，为 Web 和移动应用程序提供一组强大的功能。 cors跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。 使用方法1234567const express = require('express');const cors = require('cors');var app = express();app.use(cors()); app.listen(3000);console.log(\"server is running at localhost:3000\")","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://www.chenjundong.cn/tags/node/"}]},{"title":"linux 常见操作","slug":"linux-常见操作","date":"2018-11-05T06:38:52.000Z","updated":"2018-11-05T09:10:12.000Z","comments":true,"path":"2018/11/05/linux-常见操作/","link":"","permalink":"http://www.chenjundong.cn/2018/11/05/linux-常见操作/","excerpt":"","text":"123456789101112131415161718ls 显示文件或目录-l 列出文件详细信息l(list)-a 列出当前目录下所有文件及目录，包括隐藏的a(all)mkdir 创建目录-p 创建目录，若无父目录，则创建p(parent)cd 切换目录touch 创建空文件echo 创建带有内容的文件cat 查看文件内容cp 拷贝mv 移动或重命名rm 删除文件-r 递归删除，可删除子目录及文件-f 强制删除find 在文件系统中搜索某文件pwd 显示当前目录clear 清屏kill 杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程 1234567tar: 打包压缩-c 归档文件-x 压缩文件-z gzip压缩文件-j bzip2压缩文件-v 显示压缩或解压缩过程 v(view)-f 使用档名","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.chenjundong.cn/tags/linux/"},{"name":"redhat","slug":"redhat","permalink":"http://www.chenjundong.cn/tags/redhat/"}]},{"title":"nginx -- 项目上线","slug":"nginx-项目上线","date":"2018-11-05T06:36:52.000Z","updated":"2019-01-14T08:51:08.000Z","comments":true,"path":"2018/11/05/nginx-项目上线/","link":"","permalink":"http://www.chenjundong.cn/2018/11/05/nginx-项目上线/","excerpt":"项目上线准备工作 服务器：linux 域名：xxx.com/xxx.cn 实例对象：ftp搭建已完成 服务器：可选择阿里云, 亚马逊, 新浪云, 购买服务器 以 linux ,redhat 系统 为准使用方法：生成服务器实例传送门： 见 亚马逊 ec2 实例 域名：服务器提供商均可进行域名购买, 域名购买后, 需在 服务器平台进行解析安装: ec2 实例生成后, 进行远程登陆ftp: 远程登陆传送门：见 亚马逊ec2+ ftp 搭建","text":"项目上线准备工作 服务器：linux 域名：xxx.com/xxx.cn 实例对象：ftp搭建已完成 服务器：可选择阿里云, 亚马逊, 新浪云, 购买服务器 以 linux ,redhat 系统 为准使用方法：生成服务器实例传送门： 见 亚马逊 ec2 实例 域名：服务器提供商均可进行域名购买, 域名购买后, 需在 服务器平台进行解析安装: ec2 实例生成后, 进行远程登陆ftp: 远程登陆传送门：见 亚马逊ec2+ ftp 搭建 安装 node123456789# 下载node压缩包wget https://npm.taobao.org/mirrors/node/v10.6.0/node-v10.6.0-linux-x64.tar.xz# 解压tar -xvf node-v10.6.0-linux-x64.tar.xz# 更改node安装目录mv node-v10.6.0-linux-x64 /root/node# 配置全局环境变量 ln -s /root/node/bin/node /usr/sbin/nodeln -s /root/node/bin/npm /usr/sbin/npm 安装mysql12345678910111213141516171819202122232425262728293031# 查看是否有自带的MySql库，如果先有卸载rpm -qa | grep mysql# 删除mysql-lib(系统自带的版本过低)yum remove mysql-libs# 下载mysqlwget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.12-1.el6.x86_64.rpm-bundle.tar # 解压tar -xvf mysql-5.7.12-1.el6.x86_64.rpm-bundle.tar # 依次安装mysql包（common、libs、client、server）rpm -ivh mysql-community-common-5.7.12-1.el6.x86_64.rpmrpm -ivh mysql-community-libs-5.7.12-1.el6.x86_64.rpmrpm -ivh mysql-community-client-5.7.12-1.el6.x86_64.rpm rpm -ivh mysql-community-server-5.7.12-1.el6.x86_64.rpm # 启动mysql服务service mysqld start# 查看默认密码grep &apos;password&apos; /var/log/mysqld.log# [Note] A temporary password is generated for root@localhost: x2sX3Gb6+Dtm# root@localhost: 这里后面就是默认密码# 登陆mysql -uroot -p# 修改默认密码SET PASSWORD = PASSWORD(&apos;Abcd1234.&apos;);# ps：这里需要大小写数组字符相结合，不然会通不过# 刷新系统权限flush privileges;# 开启远程登录权限GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;Abcd1234.&apos; WITH GRANT OPTION;# 刷新系统权限flush privileges;# 接下来就可以远程登陆了 安装nginx1234567891011121314151617181920212223242526# 安装wgetyum install -y weget# 安装编译工具和相关的库文件 yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel# 下载PCRE（让Nginx支持RUL地址的重定向功能）wget https://sourceforge.net/projects/pcre/files/pcre/8.41/pcre-8.41.tar.gz# 解压tar -xvzf pcre-8.41.tar.gz# 进入安装包目录cd pcre-8.41# 编译安装./configuremake &amp;&amp; make install# 下载安装 Nginxwget http://nginx.org/download/nginx-1.14.0.tar.gz# 解压tar -xvzf nginx-1.14.0.tar.gz# 进入安装包目录：cd nginx-1.14.0# 编译安装：./configure --prefix=/usr/local/share/applications/nginx-1.14.0/ --with-http_ssl_modulemake &amp;&amp; make install# 如果此处 报 cannot open object file 需做个路径映射ln -s nginx /usr/nginx# 启动Ngnixnginx # 完整路径 /usr/local/share/applications/nginx-1.14.0/sbin/ nginx 文件配置 进入如下文件cd /usr/local/share/applications/nginx-1.14.0/conf vi nginx.conf 编辑如下配置： 1234567891011121314151617181920212223server &#123; listen 80; server_name aaa.com; # 购买的域名地址 location / &#123; root 项目路径1; # ftp上传的 项目路径 index index.html index.htm; # 端口代理 proxy_pass http://127.0.0.1:3000; &#125;&#125;# 第二个项目server &#123; listen 80; server_name bbb.com; location / &#123; root 项目路径2; index index.html index.htm; # 端口代理 proxy_pass http://127.0.0.1:4000; &#125;&#125; 编辑后重启 nginx 服务/usr/local/share/applications/nginx-1.14.0/sbin/nginx -s reload 项目部分 进行项目打包npm run bulid 将生成的index.html &amp; dist 目录 &amp; 服务器 上传到 远程 ftp 上传的地址如下 创建存放项目的文件夹及路径 12# 如果没有此文件夹 创建 mkdircd /var/www/html 启动后台服务 nginx 常规操作1234567891011# 启动nginx/usr/local/share/applications/nginx-1.14.0/sbin/nginx # 重新载入配置文件/usr/local/share/applications/nginx-1.14.0/sbin/nginx -s reload # 重启 Nginx/usr/local/share/applications/nginx-1.14.0/sbin/nginx -s reopen # 停止 Nginx/usr/local/share/applications/nginx-1.14.0/sbin/nginx -s stop 安装apache1234# 安装阿帕奇yum install httpd -y# 开启服务systemctl start httpd 添加阿帕奇工作空间修改/etc/httpd/conf/httpd.conf配置文件指定阿帕奇workspace为/var/www/html修改前1234&lt;Directory&gt; AllowOverride none Require all denied&lt;/Directory&gt; 修改后1234&lt;Directory &quot;/var/www/html&quot;&gt; AllowOverride none Require all denied&lt;/Directory&gt; 启动服务1service vsftpd status 3.域名绑定在/etc/httpd/conf目录下创建default.conf添加如下内容1234&lt;VirtualHost *:80&gt; DocumentRoot &quot;/var/www/html&quot; # 工作空间 ServerName www.aaa.com # 域名&lt;VirtualHost&gt; node 守护程序12345678910npm install forever -g# 查找forever的安装路径find / -name forever# 我这里查到是在：/root/node/bin/, 添加forever到PATHvi /etc/profile# 最后一行 i 添加 配置forever 环境变量export PATH=$PATH:/root/node/bin# esc :wq 退出编辑 找到你存放项目的路径cd /var/www/html/xxxforever server.js","categories":[],"tags":[{"name":"aws","slug":"aws","permalink":"http://www.chenjundong.cn/tags/aws/"},{"name":"ec2","slug":"ec2","permalink":"http://www.chenjundong.cn/tags/ec2/"},{"name":"linux","slug":"linux","permalink":"http://www.chenjundong.cn/tags/linux/"},{"name":"nginx","slug":"nginx","permalink":"http://www.chenjundong.cn/tags/nginx/"}]},{"title":"socket.io","slug":"socket-io","date":"2018-10-25T09:19:00.000Z","updated":"2018-11-05T09:47:22.000Z","comments":true,"path":"2018/10/25/socket-io/","link":"","permalink":"http://www.chenjundong.cn/2018/10/25/socket-io/","excerpt":"socket.io 使用Ⅰ.服务器端使用npm install socket.io --savenode 监听 3000 端口, io 对 connection 进行监听 a.监听服务器所有客户端, 建立连接并返回所有连接对象123io.sockets.on(&apos;connection&apos;,function(sockect)&#123; console.log(&apos;one user is login&apos;)&#125;) b. io connect 后, socket 进行监听事件 传递参数 123sockect.on(event, function(name)&#123; socket.emit(&quot;user&quot; + name + &quot;is login&quot;) // 通过emit 向本连接传递&#125;)","text":"socket.io 使用Ⅰ.服务器端使用npm install socket.io --savenode 监听 3000 端口, io 对 connection 进行监听 a.监听服务器所有客户端, 建立连接并返回所有连接对象123io.sockets.on(&apos;connection&apos;,function(sockect)&#123; console.log(&apos;one user is login&apos;)&#125;) b. io connect 后, socket 进行监听事件 传递参数 123sockect.on(event, function(name)&#123; socket.emit(&quot;user&quot; + name + &quot;is login&quot;) // 通过emit 向本连接传递&#125;) socket 三种事件监听io.sockets.emit() ----&gt; 向所有客户端发送广播socket.broadcast.emit() ----&gt; 向除去本连接以外的所有客户端发送广播socket.emit() -----&gt; 向建立本连接的客户端发送广播 socket 通过 emit \\ on 进行数据双向通信 在客户端、服务器端均可使用 是socket.io的核心函数emit() 发送 参数：事件名, 数据, 回调函数on() 监听 emit 发送的事件 参数：事件名，匿名函数 socket 三种默认事件connect \\ message \\ disconnect 三种事件满足条件 则 自动触发 Ⅱ. 客户端使用 客户端通过引入 即可使用123 $(document).ready(function() &#123; var socket = io.connect();&#125;); 使用this.socket.on() ---&gt; 进行事件监听 , 对服务器端发送的事件一一监听包括：connect \\ nickExisted \\ loginSuccess \\ system \\ newMsg \\ newImg使用 this.socket.on() ---&gt; 进行错误事件监听","categories":[],"tags":[{"name":"websocket","slug":"websocket","permalink":"http://www.chenjundong.cn/tags/websocket/"}]},{"title":"nexT 主题进阶","slug":"nexT-主题进阶","date":"2018-10-12T13:42:34.000Z","updated":"2019-02-15T09:35:48.000Z","comments":true,"path":"2018/10/12/nexT-主题进阶/","link":"","permalink":"http://www.chenjundong.cn/2018/10/12/nexT-主题进阶/","excerpt":"涉及背景、侧边栏、标签栏、点击效果、鼠标、萌宠背景设置F12 查看元素位置找到 themes/next/source/css/_common/components/post/post.styl添加以下代码：12345border: 1px solid #C4C6CE;border-radius: 10px;box-shadow: 0 0 5px #ADB2B2;background: white;padding: 5px 30px; 侧边栏设置① 开启侧边栏头像编辑站点配置 _config.ymlavatar: themes/next/source/images/avatar.png ② 处理","text":"涉及背景、侧边栏、标签栏、点击效果、鼠标、萌宠背景设置F12 查看元素位置找到 themes/next/source/css/_common/components/post/post.styl添加以下代码：12345border: 1px solid #C4C6CE;border-radius: 10px;box-shadow: 0 0 5px #ADB2B2;background: white;padding: 5px 30px; 侧边栏设置① 开启侧边栏头像编辑站点配置 _config.ymlavatar: themes/next/source/images/avatar.png ② 处理 页面点击添加效果1① 在/themes/next/source/js/src 下新建文件 clicklove.js并粘贴以下代码1234567891011121314151617181920212223242526272829303132333435!function(e,t,a)&#123; function n()&#123; c(&quot;.heart&#123; width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg); &#125; .heart:after,.heart:before&#123; content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed; &#125; .heart:after&#123;top: -5px;&#125; .heart:before&#123;left: -5px;&#125;&quot; ), o(), r() &#125; function r()&#123; for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;); requestAnimationFrame(r) &#125; function o()&#123; var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125; &#125; function i(e)&#123; var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a) &#125; function c(e)&#123; var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;; try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a) &#125; function s()&#123; return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot; &#125; var d=[]; e.requestAnimationFrame=function()&#123; return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125; &#125;(),n()&#125;(window,document); ② 修改layout.swig\\themes\\next\\layout_layout.swig 末尾添加：1&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt; 页面点击添加效果2① 在/themes/next/source/js/src 下新建文件 click+.js12345678910111213141516171819 $(&quot;.post-body&quot;).click(function(e)&#123; var n=Math.round(Math.random()*20);//随机数 var $i=$(&quot;&lt;b&gt;&quot;).text(&quot;+&quot;+n);//添加到页面的元素 var x=e.pageX,y=e.pageY;//鼠标点击的位置 $i.css(&#123; &quot;z-index&quot;:99999, &quot;top&quot;:y-15, &quot;left&quot;:x, &quot;position&quot;:&quot;absolute&quot;, &quot;color&quot;: &quot;red&quot; &#125;); $(&quot;body&quot;).append($i); $i.animate( &#123;&quot;top&quot;:y-180,&quot;opacity&quot;:0&#125;, 1300, function()&#123;$i.remove();&#125; ); e.stopPropagation();&#125;); ② 修改layout.swig\\themes\\next\\layout_layout.swig 末尾添加：1&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/click+.js&quot;&gt;&lt;/script&gt; ③ 注意：文件包需要有jquery 离开欺骗① 在next\\source\\js\\src 文件夹下创建 crash_cheat.js12345678910111213141516var OriginTitle = document.title; var titleTime; document.addEventListener(&apos;visibilitychange&apos;, function () &#123; if (document.hidden) &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/img/TEP.ico&quot;); document.title = &apos;╭(°A°`)╮ 页面崩溃啦 ~&apos;; clearTimeout(titleTime); &#125; else &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/favicon.ico&quot;); document.title = &apos;(ฅ&gt;ω&lt;*ฅ) 噫又好了~&apos; + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125; &#125;); ② 修改layout.swig\\themes\\next\\layout_layout.swig 末尾添加：1&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/crash_cheat.js&quot;&gt;&lt;/script&gt; 鼠标效果1⃣ 打开themes\\source_custom\\custom.styl2⃣ 将需要使用的鼠标图片 裁剪到合适大小：24～32px左右， 图片放入 sources/images 文件夹下1234567# 修改此处路径*&#123; cursor: url(&quot;/images/xxx.png&quot;),auto!important // 鼠标加载后样式图片 &#125; :active &#123; cursor: url(&quot;/images/xxx.png&quot;),auto!important。// 鼠标激活状态样式图片&#125; 萌宠","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.chenjundong.cn/tags/hexo/"},{"name":"nexT","slug":"nexT","permalink":"http://www.chenjundong.cn/tags/nexT/"}]},{"title":"aws + ec2 搭建ftp","slug":"ec2-搭建ftp","date":"2018-10-12T07:18:30.000Z","updated":"2018-11-08T03:35:56.000Z","comments":true,"path":"2018/10/12/ec2-搭建ftp/","link":"","permalink":"http://www.chenjundong.cn/2018/10/12/ec2-搭建ftp/","excerpt":"ec2 + 搭建ftp服务器前言需要注册 aws 账号 ,搭建 linux 服务器环境","text":"ec2 + 搭建ftp服务器前言需要注册 aws 账号 ,搭建 linux 服务器环境 Ⅰ.登陆远程 linux 服务器ssh root@ip地址 Ⅱ.使用yum安装vsftpdyum install -y vsftpd Ⅲ.安装后,启动FTP服务：service vsftpd start Ⅳ.启动后,查看系统监听的端口：netstat -nltp | grep 21 Ⅴ.配置ftp权限, 编辑 /etc/vsftpd/vsftpd.conf, 找到下面两处位置并修改：作用：禁用匿名用户 12 YES 改为 NO禁止切换目录 101 行 删除 #12anonymous_enable=NOchroot_local_user=YES Ⅵ.重启ftp服务service vsftpd restart创建ftp 用户 web , 为web用户创建密码 12345612useradd webecho &quot;123456&quot; | passwd --stdin Ⅶ.限制用户仅能通过 FTP 访问限制用户 ftpuser只能通过 FTP 访问服务器，而不能直接登录服务器：usermod -s /sbin/nologin web Ⅷ.为用户分配主目录/data/ftp 为主目录, 该目录不可上传文件/data/ftp/pub 文件只能上传到该目录下mkdir -p /data/ftp/pub设置访问权限chmod a-w /data/ftp &amp;&amp; chmod 777 -R /data/ftp/pub Ⅸ.设置为用户的主目录：usermod -d /data/ftp web Ⅹ.开放ftp 21 端口 或者 关闭防火墙关闭SELinux服务setenforce 0关闭防火墙iptables -F————–分割线——————设置入站规则如果 ec2实例搭建vpn 时已编辑过入站规则, 此步可忽略 ————–分割线——————本机下载 底部链接 传送门:leapFTP输入用户名, 密码 登陆 登陆成功 注意：不要使用资源管理器登陆使用 leapFTP 登陆","categories":[],"tags":[{"name":"aws","slug":"aws","permalink":"http://www.chenjundong.cn/tags/aws/"},{"name":"ec2","slug":"ec2","permalink":"http://www.chenjundong.cn/tags/ec2/"},{"name":"ftp","slug":"ftp","permalink":"http://www.chenjundong.cn/tags/ftp/"}]},{"title":"aws + ec2 + linux ","slug":"aws-ec2-lunix","date":"2018-10-12T01:41:25.000Z","updated":"2018-11-08T03:20:46.000Z","comments":true,"path":"2018/10/12/aws-ec2-lunix/","link":"","permalink":"http://www.chenjundong.cn/2018/10/12/aws-ec2-lunix/","excerpt":"aws ec2实例 + linux 搭建vpn科学上网,从我做起 电脑端准备工作Ⅰ.首先,需要有个亚马逊账号,注册准备工作：信用卡一张,授权亚马逊使用会扣$1美元可通信电话电子邮箱","text":"aws ec2实例 + linux 搭建vpn科学上网,从我做起 电脑端准备工作Ⅰ.首先,需要有个亚马逊账号,注册准备工作：信用卡一张,授权亚马逊使用会扣$1美元可通信电话电子邮箱 Ⅱ.登陆之后找到 ec2.启动一个新的实例 Ⅲ.选择创建实例的服务器类型此处选择linux Ⅳ.默认选项创建新的密钥对下载密钥对直到启动实例 Ⅴ.启动实例给实例设置 name 以便于区分 Ⅵ.编辑入站规则 Ⅴ.连接到实例初始化实例需要稍等一会实例连接成功： ———–分割线————– 操作远程linux系统1.创建root用户及密码：sudo passwd root输入两次密码, 在此期间没有任何提示2.切换到root账户：su root3.使用root身份编辑亚马逊主机的ssh登录方式vi /etc/ssh/sshd_config把 PasswordAuthentication no 改为 PasswordAuthentication yes如果没有则新插进去使用 i 进行修改出现可修改 insert , 修改后 esc :wq 退出4.重启sshd使修改生效service sshd restart5.使用用户名密码远程连接ssh root@ip地址————分割线————– 搭建vpnⅠ.安装wgetyum -y install wgetⅡ.安装setuptoolswget --no-check-certificate https://bootstrap.pypa.io/ez_setup.py sudo python ez_setup.py --insecureⅢ.下载pip安装包，解压12345678910# 下载压缩包wget https://pypi.python.org/packages/11/b6/abcb525026a4be042b486df43905d6893fb04f05aac21c32c638e939e447/pip-9.0.1.tar.gz#md5=35f01da33009719497f01a4ba69d63c9# 解压缩包tar -xf pip-9.0.1.tar.gz# 切换路径cd pip-9.0.1# 安装sudo python setup.py install# 添加引用ln -s /usr/local/python27/bin/pip /usr/bin/pip #如果报 File exists 忽略此步 Ⅳ.安装shadowsocks远程客户端pip install shadowsocksⅤ.添加shadowsocks配置文件123mkdir /etc/shadowsocks/cd /etc/shadowsocks/vi config.json Ⅵ.粘贴已下内容123456789&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:8388, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;替换为密码&quot;, &quot;timeout&quot;:600, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;:false&#125; Ⅶ.启动服务ssserver -c /etc/shadowsocks/config.json -d start看到服务启动成功—————–分割线——————Ⅰ.本机电脑安装 shadowsocks传送门：shadowsocks Ⅱ.配置 shadowsocks填写ip, 登陆密码 Ⅲ.地址栏：google.com测试是否可科学上网","categories":[],"tags":[{"name":"aws","slug":"aws","permalink":"http://www.chenjundong.cn/tags/aws/"},{"name":"ec2","slug":"ec2","permalink":"http://www.chenjundong.cn/tags/ec2/"},{"name":"vpn","slug":"vpn","permalink":"http://www.chenjundong.cn/tags/vpn/"}]},{"title":"nexT主题+valine评论系统","slug":"nexT主题-valine评论系统","date":"2018-10-11T03:08:37.000Z","updated":"2018-10-12T01:30:14.000Z","comments":true,"path":"2018/10/11/nexT主题-valine评论系统/","link":"","permalink":"http://www.chenjundong.cn/2018/10/11/nexT主题-valine评论系统/","excerpt":"nexT 安装Ⅰ.123git clone https://github.com/iissnan/hexo-theme-next themes/nextcd themes/nextgit pull 配置（主题配置+根站点配置）Ⅱ.根目录 _config.yml 配置theme: next III.切换主题：在themes _config.yml 中 找到 # Schemes：挑选一个主体进行解注释","text":"nexT 安装Ⅰ.123git clone https://github.com/iissnan/hexo-theme-next themes/nextcd themes/nextgit pull 配置（主题配置+根站点配置）Ⅱ.根目录 _config.yml 配置theme: next III.切换主题：在themes _config.yml 中 找到 # Schemes：挑选一个主体进行解注释 Ⅳ.更改语言：在 根目录 _config.yml 配置language: zh-Hans V.tags 标签分类：themes _config.yml 配置12345678menu:home: / || home //首页about: /about/ || user //关于tags: /tags/ || tags //标签 // 此处解注释categories: /categories/ || th //分类archives: /archives/ || archive //归档schedule: /schedule/ || calendar //日程表sitemap: /sitemap.xml || sitemap //站点地图 此处使用 hexo new page “tags”并在 tags/index.md 中进行编辑：12345---title: tagsdate: 2018-10-11 10:36:20type: &quot;tags&quot;--- Ⅵ.设置动态背景：在 themes _config.yml 中配置canvas_nest: ture Ⅶ.修改底部标签样式：在 themes\\next\\layout_macro\\post.swig command+f搜索rel=”tag”&gt;# ,将#替换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; Ⅷ.配置评论系统：打开 leancloud 平台copy appID + App Key对应 themes _config.yml 中配置 Ⅸ.配置主题线条色彩：打开 themes\\next\\source\\lib\\canvas-nest找到 “opacity,color”修改 opacity,color . 调整线条颜色 V.123hexo cleanhexo ghexo d","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.chenjundong.cn/tags/hexo/"},{"name":"nexT","slug":"nexT","permalink":"http://www.chenjundong.cn/tags/nexT/"},{"name":"valine","slug":"valine","permalink":"http://www.chenjundong.cn/tags/valine/"}]},{"title":"vue-cli+axios+百度搜索引擎接口调调用_实现搜索功能(踩坑)","slug":"vue-cli-axios-百度搜索引擎接口调调用—用—实现搜索功能","date":"2018-07-18T08:02:11.000Z","updated":"2018-07-18T09:22:00.000Z","comments":true,"path":"2018/07/18/vue-cli-axios-百度搜索引擎接口调调用—用—实现搜索功能/","link":"","permalink":"http://www.chenjundong.cn/2018/07/18/vue-cli-axios-百度搜索引擎接口调调用—用—实现搜索功能/","excerpt":"vue_search 小案例实现方式 使用 vue-cli + webpack + axios 实现调用 百度搜索引擎接口重点： 使用 axios http 跨域请求、webpack 配置 跨域请求设置 首先要踩的几个坑：注意eslint 语法规范第一步. vue-cli 项目初始化 vue init webpack vue_search 注意 eslint \\ vue-router \\ npm install 的安装使用 安装 插件库 axios —&gt; 基于 http 协议 npm install –save-dev 如图： 第二步.文件夹路径 cd 进入时， 大小写一定要注意，否则 eslint 警告","text":"vue_search 小案例实现方式 使用 vue-cli + webpack + axios 实现调用 百度搜索引擎接口重点： 使用 axios http 跨域请求、webpack 配置 跨域请求设置 首先要踩的几个坑：注意eslint 语法规范第一步. vue-cli 项目初始化 vue init webpack vue_search 注意 eslint \\ vue-router \\ npm install 的安装使用 安装 插件库 axios —&gt; 基于 http 协议 npm install –save-dev 如图： 第二步.文件夹路径 cd 进入时， 大小写一定要注意，否则 eslint 警告 第三步. main.js 引入axios . 并加入 prototype , 使 axios 可以全局使用 config 下 index.js 中配置 proxyTable 配置如下： 123456789101112proxyTable: &#123; &apos;/api&apos;: &#123; target: &apos;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&apos;,//设置你调用的接口域名和端口号 别忘了加http changeOrigin: true, pathRewrite: &#123; &apos;^/api&apos;: &apos;/&apos; // 这里理解成用‘/api’代替target里面的地址， // 后面组件中我们掉接口时直接用api代替 比如我要调 // 用&apos;http://40.00.100.100:3002/user/add&apos;，直接写&apos;/api/user/add&apos;即可 &#125; &#125; &#125;, 第四步.接口调用: 百度里面扒接口 第五步.axios调用： this.$http(&apos;/api&apos;,{ params: { wd: this.msg } }).then(res =&gt; { console.log(res.data) }, res =&gt; { alert(&apos;网络错误&apos;) }) 完成","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.chenjundong.cn/tags/hexo/"},{"name":"vue-cli","slug":"vue-cli","permalink":"http://www.chenjundong.cn/tags/vue-cli/"},{"name":"axios","slug":"axios","permalink":"http://www.chenjundong.cn/tags/axios/"},{"name":"http","slug":"http","permalink":"http://www.chenjundong.cn/tags/http/"}]},{"title":"valine体验--开启评论系统","slug":"valine体体验-开启评论系统","date":"2018-06-26T14:57:46.000Z","updated":"2019-01-14T08:51:44.000Z","comments":true,"path":"2018/06/26/valine体体验-开启评论系统/","link":"","permalink":"http://www.chenjundong.cn/2018/06/26/valine体体验-开启评论系统/","excerpt":"hexo 作为静态博客很受欢迎,除了可以应该用github上大量主题之外还可以开启友链、打赏、评论等互动功能 hexo 搭载了众多可使用的评论系统,如： 畅言,多说,有言,disqus…等等目前本博客使用 valine 评论系统原因有三： 1.轻量级 2.注册快捷 3.简单优雅大方 markdown语法支持 4.官方解释：Leancloud的快速、简洁且高效的无后端评论系统 这里放出链接 valine","text":"hexo 作为静态博客很受欢迎,除了可以应该用github上大量主题之外还可以开启友链、打赏、评论等互动功能 hexo 搭载了众多可使用的评论系统,如： 畅言,多说,有言,disqus…等等目前本博客使用 valine 评论系统原因有三： 1.轻量级 2.注册快捷 3.简单优雅大方 markdown语法支持 4.官方解释：Leancloud的快速、简洁且高效的无后端评论系统 这里放出链接 valine 使用方法如下： 首先配置 leancloud 平台①valine②进入链接 leancloud 如果没有账号,快速注册一个③快速创建一个应用👇 如图 ④进入控制台找到设置 如图复制 appid 与 appkey ⑤安全中心绑定域名 此处注意踩坑 http 与 https 两者缺一不可 其次配置 hexo①目前使用主题为 yilia 主题 需要去看主题说明 此处传送链接yilia + valine②安装 valine 插件npm install valine --save③在yilia 配置文件中进行相关配置如图： a.配置说明 b.yilia theme config 配置开启： c.配置layout/partial/article.ejs: d.新建layout/post/vaine.ejs 并复制保存以下代码 ④分别保存并运行 hexo d搞定 感谢 litten valine 大佬们","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.chenjundong.cn/tags/Git/"},{"name":"github","slug":"github","permalink":"http://www.chenjundong.cn/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://www.chenjundong.cn/tags/hexo/"},{"name":"valine","slug":"valine","permalink":"http://www.chenjundong.cn/tags/valine/"}]},{"title":"gitpush冲突解决","slug":"gitpush冲突解决","date":"2018-06-25T13:29:46.000Z","updated":"2019-01-14T08:48:32.000Z","comments":true,"path":"2018/06/25/gitpush冲突解决/","link":"","permalink":"http://www.chenjundong.cn/2018/06/25/gitpush冲突解决/","excerpt":"","text":"如题冲突原因：远程端或有合作的小伙伴已经更新了代码本地代码再次进行提交时 发生冲突 造成如下图报错： 此时解决办法：① 使用git pull 先拉远程库到本地② 在进入的 vim 界面进行如下操作 press i 进入输入模式 按 esc 退出修改 commit 输入 :wq 退出并进行合并🌂 重新使用 git push搞定","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.chenjundong.cn/tags/Git/"},{"name":"github","slug":"github","permalink":"http://www.chenjundong.cn/tags/github/"}]},{"title":"new 关键字做的四件事","slug":"new-关键字做的四件事-一段代码了解一下","date":"2018-05-31T09:29:14.000Z","updated":"2019-01-21T02:18:06.000Z","comments":true,"path":"2018/05/31/new-关键字做的四件事-一段代码了解一下/","link":"","permalink":"http://www.chenjundong.cn/2018/05/31/new-关键字做的四件事-一段代码了解一下/","excerpt":"","text":"如题： 放代码 12345678910111213141516171819202122function Person() &#123; this.name = &apos;eric&apos;; this.age = 7; &#125;var name = new Person();// 1.创建一个空对象obj var obj = &#123;&#125;// 2.设置obj的__proto__为原型 obj.__proto__ = Person.prototype;// 3.使用obj作为上下文调用Person函数 var person1 = Person.call(obj); // 4.如果构造函数返回的是原始值，那么这个返回值会被忽略 如果构造函数返回的是对象，就返回这个对象if (typeof person1 == &apos;object&apos;)&#123; return person1; &#125;else&#123; return person2 &#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://www.chenjundong.cn/tags/js/"}]},{"title":"this 5种指向","slug":"this-5种指向","date":"2018-05-29T07:19:12.000Z","updated":"2019-01-14T08:51:30.000Z","comments":true,"path":"2018/05/29/this-5种指向/","link":"","permalink":"http://www.chenjundong.cn/2018/05/29/this-5种指向/","excerpt":"this 的指向问题this 的指向容易头晕此处翻了大神的文章 得出 this ——&gt; 5种指向 下面准备好编辑器, 慢慢看 第一种1. this 指向 当前调用 它 的对象123456789101112131415161718 var obj = &#123; a: 20, fun: function()&#123; console.log(this.a) &#125;&#125; obj.fun(); //20 // 此时 this --&gt; obj obj.fun = &#123; a: 30, fun: function()&#123; console.log(this.a) &#125; &#125; obj.fun.fun(); //30 // 此时 this --&gt; fun // this 指向只在上一级对象进行绑定第二种2. this 指向全局12345 var a = 20; var fun = function()&#123; console.log(this.a) // fun 为全局 this --&gt; 全局&#125;","text":"this 的指向问题this 的指向容易头晕此处翻了大神的文章 得出 this ——&gt; 5种指向 下面准备好编辑器, 慢慢看 第一种1. this 指向 当前调用 它 的对象123456789101112131415161718 var obj = &#123; a: 20, fun: function()&#123; console.log(this.a) &#125;&#125; obj.fun(); //20 // 此时 this --&gt; obj obj.fun = &#123; a: 30, fun: function()&#123; console.log(this.a) &#125; &#125; obj.fun.fun(); //30 // 此时 this --&gt; fun // this 指向只在上一级对象进行绑定第二种2. this 指向全局12345 var a = 20; var fun = function()&#123; console.log(this.a) // fun 为全局 this --&gt; 全局&#125;2.1 易出现的错误12345678910111213var a = 10;var obj = &#123; a: 20, fun: function()&#123; console.log(this.a); var foo = function()&#123; console.log(this.a) &#125; foo(); //2 // 调用前方没有对象 , this 指向全局 &#125;&#125;obj.fun(); // 20此时 obj.fun() this –&gt; obj, foo() –&gt; 无对象调用, this –&gt;全局 全局 a = 10此时 使 foo()内 this 指向 a:20 ,需要 缓存 this1234567891011121314 var a = 10; var obj = &#123; a: 20, fun: function()&#123; console.log(this.a); // this --&gt; a:20 var that = this; // 缓存当前 this 指向 var foo = function()&#123; console.log(that.a) // that --&gt; a:20 &#125; foo(); &#125; &#125;obj.fun();2.2 易出现的错误12345678910111213141516var a = 10;var obj = &#123; a: 20, fun: function()&#123; console.log(this.a) // this--&gt; a:20 &#125;&#125;obj.fun(); var funOut = obj.fun; // 函数未调用funOut(); // this指向全局 a:10 var obj2 = &#123; a: 30, fun: obj.fun&#125;obj2.fun(); // 30此时 三处调用 三处输出① line9 obj.fun() this 指向obj this.a = 20② line11 funOut() –&gt; window.funOut()this 指向全局 this.a = 10③ line16 obj2.fun() this 指向obj2 this.a = 30第三种3.this 指向call 或 apply12345678910var obj = &#123; a: 20, fun: function()&#123; console.log(this.a) &#125;&#125;var obj2 = &#123; a: 30&#125;obj.fun.call(obj2); // 30此时 使用 call 强行将 obj2 的属性绑定给 objthis–&gt;obj2 this.a = 30第四种4.this 指向new 构造函数创建的对象 1234function Money()&#123; this.money = 100;&#125; var eric = new Money(); //this 指向 new 出来的 对象第五种5.this 指向当前对象所调用的 callback 12345&lt;div id=\"box\"&gt;内容区&lt;/div&gt;var box = document.getElementById(\"box\")box.onclick = function()&#123; this.innerHTML= \"click me\";&#125;此时 调用 callback 的对象为 box , this 将指向 传给 调用 callback 的对象this –&gt; boxover.","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://www.chenjundong.cn/tags/js/"}]},{"title":"git-基础操作","slug":"git-基础操作","date":"2018-05-27T07:30:12.000Z","updated":"2019-01-14T08:48:50.000Z","comments":true,"path":"2018/05/27/git-基础操作/","link":"","permalink":"http://www.chenjundong.cn/2018/05/27/git-基础操作/","excerpt":"","text":"git 基础使用 首先 git 是个版本控制工具① 拥有一个自己的github 账号：github② 安装 git pc 客户端 git③ 给电脑授权,生成 ssh key$ ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot;c盘生成 rsa.pub 文件④ 添加计算机使用权限github –&gt;setting –&gt; ssh and GPG keys 添加⑤ 全局配置 用户名 和 邮箱 并进行验证123git config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx@xxx.com&quot; ssh -T git@github.com ⑥ git 本地端仓库git init⑥ github 远程仓库 推送1234git add .git commit -m &quot;提交到...&quot;git remote add origin git@github.com:xxx/xxx.gitgit push -u origin master ⑦ 第二次此仓库提交123git add .git commit -m &quot;第二次提交...&quot;git push over.","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.chenjundong.cn/tags/Git/"},{"name":"github","slug":"github","permalink":"http://www.chenjundong.cn/tags/github/"}]},{"title":"hexo+github搭建个人博客网站","slug":"hexo+github搭建个人博客网站","date":"2018-05-22T07:38:47.000Z","updated":"2019-02-15T09:38:37.021Z","comments":true,"path":"2018/05/22/hexo+github搭建个人博客网站/","link":"","permalink":"http://www.chenjundong.cn/2018/05/22/hexo+github搭建个人博客网站/","excerpt":"","text":"环境搭建node一款流行的web服务器，也是一款服务器端语言。 安装下载v8.11.2版本的msi安装包，双击，默认配置安装。 检测环境win+r打开cmd窗口，输入1node -v 如果显示版本号，则代表本机已经安装 常规cmd命令 cd:改变操作目录cd ..:代表返回上级目录cd /:返回当前盘符的根目录cd 文件名 :进入某目录 ipconfig/all:可以查看本机的ip地址 hexo new 博客名(可中文)：新建一篇博客的名称。 hexo快速、简洁且高效的博客框架 安装hexo脚手架(1)win+r打开运行窗口，输入cmd回车(2)在新打开的cmd输入1npm install hexo-cli -g npm:node的包管理器（类似于Apple store和安卓应用商店）提供node工具包的安装和卸载服务install:导入 安装cli:脚手架-g:对前面命令的修饰，表示全局安装（在本机任何路径都可以访问） 初始化博客项目(1)在命令行cd到需要存放博客项目的路径(2)使用如下命令：1hexo init 项目名称 hexo init blog blog为项目名称，必须为英文(3)进入项目目录1cd blog (4)安装项目依赖1npm install (5)启动服务器1hexo server 简写:hexo s(6)预览在浏览器地址栏输入localgost:4000或者127.0.0.1：4000 添加新博客1.在命令框输入hexo new 博客名称(可中文)。","categories":[],"tags":[]},{"title":"markdown语法","slug":"markdown语法","date":"2018-05-22T03:09:25.000Z","updated":"2018-10-27T06:18:38.000Z","comments":true,"path":"2018/05/22/markdown语法/","link":"","permalink":"http://www.chenjundong.cn/2018/05/22/markdown语法/","excerpt":"","text":"这是一级标题这是一级标题 这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题常规字体样式我是斜体我也是斜体我是不是斜体 我是粗体我是不是粗体 我是加粗斜体我是删除线 超链接欢迎来到百度点我跳转到我的第一篇博客 自动链接http://www.baidu.com 列表无序列表使用*或者+或者-表示无序列表 手机 电脑 相机 苹果 三星 oppo 吃鸡魔兽LOL 有序列表 小米 vivo 华为 图片插入引入本地图片的方法：1.在blog/source目录下新建一个文件夹，如1232.将想要导入的图片放进123文件夹3.md文件里面通过如下方式引入 跳转到lorem 代码块12345while(alive)&#123; eate(); sleep(); code();&#125; 1&lt;h1 align=&quot;center&quot;&gt;标题&lt;/h1&gt;","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://www.chenjundong.cn/tags/markdown/"},{"name":"all","slug":"all","permalink":"http://www.chenjundong.cn/tags/all/"},{"name":"语法","slug":"语法","permalink":"http://www.chenjundong.cn/tags/语法/"},{"name":"教程","slug":"教程","permalink":"http://www.chenjundong.cn/tags/教程/"}]},{"title":"Git 工作流以及--branch 使用","slug":"Git-branch-使用","date":"2018-05-21T15:12:03.000Z","updated":"2018-06-28T01:03:54.000Z","comments":true,"path":"2018/05/21/Git-branch-使用/","link":"","permalink":"http://www.chenjundong.cn/2018/05/21/Git-branch-使用/","excerpt":"说到 Git 的使用 , 首先 , 这是一个版本控制工具 在 Git 的使用中, 存在着 工作流也即是working tree主要包括：① 工作目录 – 包括实际存储的文件② 缓存区(Index) – git 缓存区 保存临时的改动③ HEAD – 指向最后一次提交的结果 扒张图如下： 👆 通过上图能够看出来 , git HEAD 最后指向的 一定是通过 commit 后的最终文件 存在着以下的步骤： git add eg.txt —&gt;将文件 添加到缓存区 git commit -m “ 提交信息 “ —&gt;此时改动提交到了 HEAD git push —&gt;提交到 远程仓库","text":"说到 Git 的使用 , 首先 , 这是一个版本控制工具 在 Git 的使用中, 存在着 工作流也即是working tree主要包括：① 工作目录 – 包括实际存储的文件② 缓存区(Index) – git 缓存区 保存临时的改动③ HEAD – 指向最后一次提交的结果 扒张图如下： 👆 通过上图能够看出来 , git HEAD 最后指向的 一定是通过 commit 后的最终文件 存在着以下的步骤： git add eg.txt —&gt;将文件 添加到缓存区 git commit -m “ 提交信息 “ —&gt;此时改动提交到了 HEAD git push —&gt;提交到 远程仓库 下面是正文： 分支部分同样扒张图 来看一下 创建一个分支git checkout -b feature_x 此处 是创建分支 feature_x 并 切换到 分支 feature_x 切换分支git checkout feature_x 此处为切换分支 到 feature_x 同样可以切换回 主分支(master) 切换回主分支git checkout master 分支之间切换是为了保存你暂时不想合并的 改动内容① 可在 当前 分支 编写 需要修改 或者 还未完成的 工作② 使用 git commit -m “提交当前分支” 至 feature_x 并进行 push 使远程 feature_x 提交成功 如下图所示：③ 此时主分支 看不到 其他分支的内容 可在feature_x 里面继续工作④ 完成工作后 将当前分支合并到 主分支(master)1234git add .git commit -m &quot;合并feature_x 分支的工作&quot;git merge feature_xgit push ⑤ 此时主分支 master 能够看到 feature_x 提交的内容 到此 , 也就可以愉快的跟小伙伴组团开发了 简单来讲：首先, 要存在一个主分支 master 其次, 每个人有一个自己的分支 eg： branch01 进行自己代码的提交: git add . git commit -m git push 再次, 规定每隔一段时间, 需要一个小伙伴进行合并分支git merge branch01 再次次, 每个小伙伴 使用git pull更新自己的 master 分支, 进行库的合并 ,使之与 远程端 master 一致 ………如此 … 循环操作 ………直到 最终版本的确定 恭喜又习得新技能~","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.chenjundong.cn/tags/Git/"},{"name":"github","slug":"github","permalink":"http://www.chenjundong.cn/tags/github/"}]},{"title":"hexo + domain绑定","slug":"custom-domain","date":"2018-05-03T02:22:14.000Z","updated":"2018-11-05T08:02:26.000Z","comments":true,"path":"2018/05/03/custom-domain/","link":"","permalink":"http://www.chenjundong.cn/2018/05/03/custom-domain/","excerpt":"绑定阿里云域名三处操作：github操作 hexo端文件操作 阿里云端操作","text":"绑定阿里云域名三处操作：github操作 hexo端文件操作 阿里云端操作 第一处操作①github 仓库中找到 .io 的库② settings 进入如下界面并进行更改 第二处操作①添加 CNAME 文件打开 CNAME 文件 添加内容如下： xxx.com②hexo 重新部署推送至github 12hexo ghexo d 第三处操作① 保证阿里云域名 已经过实名认证② 进入域名服务 进行 域名解析③ 添加两条解析 如图所示： 第一条添加记录类型：A主机记录：www xxxx.域名解析路线：默认记录值：对应的github的ip地址 (此处可通过ping获取) 第二条添加记录类型：CNAME主机记录：@ xxxx.域名解析路线：默认记录值：username.github.io 完成稍等几分钟,可打开域名进行访问","categories":[],"tags":[{"name":"github","slug":"github","permalink":"http://www.chenjundong.cn/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://www.chenjundong.cn/tags/hexo/"},{"name":"domain","slug":"domain","permalink":"http://www.chenjundong.cn/tags/domain/"}]},{"title":"sublime","slug":"sublime","date":"2018-03-05T06:23:43.000Z","updated":"2018-06-28T01:03:54.000Z","comments":true,"path":"2018/03/05/sublime/","link":"","permalink":"http://www.chenjundong.cn/2018/03/05/sublime/","excerpt":"","text":"sublime 3安装及使用 作为轻量级编辑器，sublime如它的名字一样，好用，反应迅速，插件强大。官网一般有安装包下载 sublimetext.com激活码一般度娘找 插件使用ctrl+shift+p 进入控制台，当然前提是安装了控制台功能控制台功能：在 ctrl+` 打开的底部任务栏窗口处添加以下代码 import urllib.request,os,hashlib; h = &apos;7183a2d3e96f11eeadd761d777e62404&apos; + &apos;e330c659d4bb41d3bdf022e94cab3cd0&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 安装成功之后，ctrl+shift+p 进入控制台 输入install package项强大的插件安装功能 推荐使用①SublimeLiner – 类似于 webstrom\\Idea 里面的 ToDo 能够高亮一些特别的注释②Emmet (既是原来的Zen Coding) 在editplus里面也以 Emmet 显示③JS Format JS代码格式化插件④auto Prefixer Css3代码前缀自动补全⑤Bracket Hightlighter 代码匹配，不担心掉括号了 还可以进行主题的选择同样通过 ctrl+shift+p 进入控制台 输入install package项输入想要的theme主题 或 在输入的 theme 列表项相应选择安装 移除插件调出控制台remove package输入需要删除的 package","categories":[],"tags":[{"name":"sublime3","slug":"sublime3","permalink":"http://www.chenjundong.cn/tags/sublime3/"}]},{"title":"JS数据属性&访问器属性","slug":"JS数据属性-访问器属性","date":"2018-02-28T08:43:32.000Z","updated":"2019-01-14T08:49:20.000Z","comments":true,"path":"2018/02/28/JS数据属性-访问器属性/","link":"","permalink":"http://www.chenjundong.cn/2018/02/28/JS数据属性-访问器属性/","excerpt":"","text":"javaScript 中,一切皆对象。对象中可以包含”基本值、对象、函数”。创建自定义函数 第一种字面直接量1234567var person = &#123; name:&apos;eric&apos;, age:24, intr:function()&#123; console.log(this.name) &#125; &#125; 第二种创建对象实例123456var person = new Object();person.name = &quot;eric&quot;;person.age = 24;person.intr = function()&#123; console.log(person.name)&#125; 属性类型javaScript中定义了两种不用的属性类型： 一种是数据属性：用于储存属性的值 另一种是访问器属性：一般用来进行get/set操作 数据属性Configurable、Enumerable、Writable、Value前三者默认值为true,Value默认值为特定值设置对象数据属性为不可更改：123456789var person = &#123; name :&apos;eric&apos;,&#125;Object.definerProperty(person,&apos;name&apos;,&#123; configurable:false;&#125;) consoel.log(person.name); //eric&lt;font color=&quot;blue&quot;&gt;delete&lt;/font&gt; person.name;console.log(person.name); //eric 访问器属性 getter/setter函数1234567891011121314151617181920212223242526var person = &#123; name:&apos;hammer&apos;, age:&apos;23&apos;, gender:&apos;male&apos;&#125;Object.defineProperty(person,&apos;age&apos;,&#123; get:function()&#123; return this._age; //此时age属性只读 &#125;&#125;);Object.defineProperty(person,&apos;name&apos;,&#123; set:function(name)&#123; return this._name = name; //此时name属性只写 &#125;&#125;);Object.defineProperty(person,&apos;gender&apos;,&#123; //此时gender属性可读可写 get:function()&#123; return this._gender; &#125; set:function(gender)&#123; return this._gender = gender; &#125;&#125;);","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://www.chenjundong.cn/tags/js/"},{"name":"es5","slug":"es5","permalink":"http://www.chenjundong.cn/tags/es5/"}]},{"title":"php中索引数组与关联数组的区别","slug":"php中索引数组与关联数组的区别","date":"2018-02-04T02:05:01.000Z","updated":"2018-06-28T01:03:54.000Z","comments":true,"path":"2018/02/04/php中索引数组与关联数组的区别/","link":"","permalink":"http://www.chenjundong.cn/2018/02/04/php中索引数组与关联数组的区别/","excerpt":"","text":"最直观的区别： 用数字表示键名—索引数组索引数组的键值为整数，从”0”开始，向下类推 索引数组的几种表现形式 $arr[0] = ‘Eric’; $arr = array(‘0’ =&gt; ‘Eric’); $arr = array(‘Eric’); 用字符串表示键名的数组—关联数组关联数组与索引数组的区别只在于键值上，关联数组键值是人为设定的如：$arr[‘name’] = ‘Eric’;","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.chenjundong.cn/tags/php/"}]},{"title":"markdown基本语法使用","slug":"markdown","date":"2018-02-02T06:42:43.000Z","updated":"2019-01-14T08:55:32.000Z","comments":true,"path":"2018/02/02/markdown/","link":"","permalink":"http://www.chenjundong.cn/2018/02/02/markdown/","excerpt":"二级标题三级标题####### 只到6级标题 两个星号之间是粗体字一个星号是斜体字1 . 有序列表2 . 有序列表3 . 有序列表","text":"二级标题三级标题####### 只到6级标题 两个星号之间是粗体字一个星号是斜体字1 . 有序列表2 . 有序列表3 . 有序列表 markdown 生成表格语法感觉略累 Tables Age Gender name 25 gender eric 23 male hammer 24 female 使用markdown编辑代码 &lt;div class=&quot;&quot;&gt;放个片段&lt;/div&gt;","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.chenjundong.cn/tags/hexo/"},{"name":"markdown","slug":"markdown","permalink":"http://www.chenjundong.cn/tags/markdown/"}]},{"title":"部分自定义设置--不定期更新","slug":"部分自定义设置","date":"2018-02-01T09:35:15.000Z","updated":"2018-06-28T01:03:54.000Z","comments":true,"path":"2018/02/01/部分自定义设置/","link":"","permalink":"http://www.chenjundong.cn/2018/02/01/部分自定义设置/","excerpt":"","text":"链接处理方式This is an 链接[bing.com](http://bing.com/) 如何更改主题如：① git clone https://github.com/litten/hexo-theme-yilia.git② 进入_config.yml 修改 line75 theme:yilia 头像加载方式① 进入themes 主题文件夹② _config.yml 配置文件③ 找到 avatar:img/xxx.jpg④ 将相应文件拷到相应文件夹中 图片加载方式① 首先在_config.yml配置文件中更改② post_asset_folder:true③ hexo new &quot;fileName&quot;④ 在生成的 fileName.md 文件中写入：⑤ ⑥ 第五条内容会被自动解析，无法显示 博客 favicon 加载方法裁剪 32x32 后缀为ico的图片将图片放入 theme\\source\\img 中并重命名 给相似类型或主题的文章添加标签在顶部 tags下方，以 - 标签名 格式即可","categories":[],"tags":[]},{"title":"hexo搭建博客","slug":"hexo搭建博客","date":"2018-02-01T04:59:42.000Z","updated":"2019-01-21T02:23:30.000Z","comments":true,"path":"2018/02/01/hexo搭建博客/","link":"","permalink":"http://www.chenjundong.cn/2018/02/01/hexo搭建博客/","excerpt":"根据以下几个步骤进行，注意步骤顺序不要错 新建文件夹(Blog) git bash here --- npm install -g hexo-cli(安装后不报错，否则清空文件夹—-重新开始) 创建 hexo 文件夹 –进入hexo文件夹①git bash here —- hexo init②npm intall (拉node包) 完成上述步骤：① hexo g② hexo s③ localhost:4000 git —-个人博客远程库搭建①新建库：命名：xxx.github.io 此库名要与 用户名一致②连接库：hexo文件夹内 _config.yml 打开deploy:type: gitrepository: http://github.com/xxx/xxx.github.io.gitbranch: master 此处注意两点:type:git 、 repository:https—-&gt;http 更改yml文件保存：① hexo g② 部署包(拉包)npm install hexo-deployer-git --save③ hexo d 完成nighthighness.github.io可打开 域名绑定见另篇内容绑定阿里云域名","text":"根据以下几个步骤进行，注意步骤顺序不要错 新建文件夹(Blog) git bash here --- npm install -g hexo-cli(安装后不报错，否则清空文件夹—-重新开始) 创建 hexo 文件夹 –进入hexo文件夹①git bash here —- hexo init②npm intall (拉node包) 完成上述步骤：① hexo g② hexo s③ localhost:4000 git —-个人博客远程库搭建①新建库：命名：xxx.github.io 此库名要与 用户名一致②连接库：hexo文件夹内 _config.yml 打开deploy:type: gitrepository: http://github.com/xxx/xxx.github.io.gitbranch: master 此处注意两点:type:git 、 repository:https—-&gt;http 更改yml文件保存：① hexo g② 部署包(拉包)npm install hexo-deployer-git --save③ hexo d 完成nighthighness.github.io可打开 域名绑定见另篇内容绑定阿里云域名 配置Sitetitle: xxxsubtitle: xxx–BloGdescription: 1+1=？author: xxxlanguage: zh-CNtimezone: Writing38line post_asset_folder: true PaginationSet per_page to 0 to disable paginationper_page: 5pagination_dir: page hexo常见命令新建文章hexo new &quot;postName&quot;新建页面hexo new page &quot;pageName&quot;生成静态页面至public目录hexo generate开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo server部署到GitHubhexo deploy查看帮助hexo help查看Hexo的版本hexo version 命令缩写hexo nhexo ghexo shexo d 组合命令生成并本地预览hexo s -g生成并上传hexo d -g","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.chenjundong.cn/tags/hexo/"}]},{"title":"如何推送一篇hexo文章","slug":"myNew-post","date":"2018-02-01T03:16:04.000Z","updated":"2018-06-28T01:03:54.000Z","comments":true,"path":"2018/02/01/myNew-post/","link":"","permalink":"http://www.chenjundong.cn/2018/02/01/myNew-post/","excerpt":"","text":"如何推送一篇文章① git 中 使用 hexo new &quot;xxxx&quot; 命令新建文件② 进入hexo source &gt;_posts 文件③ 使用 markdown 写文章④ hexo g⑤ hexo s 启动本地服务器⑥ hexo d 部署至github","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.chenjundong.cn/tags/hexo/"}]}]}